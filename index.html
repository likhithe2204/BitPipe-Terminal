<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BitPipe Terminal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: rgba(26, 27, 38, 0.85);
            --text-color: #a9b1d6;
            --prompt-color: #7aa2f7;
            --header-bg: rgba(31, 35, 53, 0.85);
            --border-color: #2f3549;
            --scrollbar-track: #1e1e1e;
            --scrollbar-thumb: #555;
            --font-main: 'Fira Code', monospace;
        }
        [data-theme="hacker"] {
            --bg-color: rgba(0, 0, 0, 0.75);
            --text-color: #00ff00;
            --prompt-color: #00ff00;
            --header-bg: rgba(10, 10, 10, 0.75);
            --border-color: #222;
        }
        [data-theme="solarized"] {
            --bg-color: rgba(0, 43, 54, 0.8);
            --text-color: #839496;
            --prompt-color: #268bd2;
            --header-bg: rgba(7, 54, 66, 0.8);
            --border-color: #0d4150;
        }
        body {
            background-image: url('https://placehold.co/1920x1080/1a1b26/7aa2f7?text=.');
            background-size: cover;
            background-position: center;
            font-family: var(--font-main);
            color: var(--text-color);
        }
        .glass-panel {
            background-color: var(--bg-color);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
        }
        header { 
            background-color: var(--header-bg);
            border-bottom: 1px solid var(--border-color);
        }
        .prompt-color { color: var(--prompt-color); }
        .text-color { color: var(--text-color); }
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--scrollbar-track); }
        ::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #777; }
        
        .prompt-input {
            background: transparent;
            border: none;
            outline: none;
            color: var(--text-color);
            flex-grow: 1;
            font-family: var(--font-main);
            caret-color: var(--text-color);
            animation: blink 1.2s steps(2) infinite;
        }
        @keyframes blink {
            0% { caret-color: var(--text-color); }
            50% { caret-color: transparent; }
            100% { caret-color: var(--text-color); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
    </style>
</head>
<body class="flex items-center justify-center h-screen p-4" data-theme="tokyo-night">

    <div class="w-full max-w-4xl h-[90vh] flex flex-col rounded-lg shadow-2xl glass-panel">
        <header class="p-3 flex items-center justify-center text-center relative rounded-t-lg">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="absolute left-4 top-1/2 -translate-y-1/2 text-gray-500"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>
            <h1 class="text-xl font-bold">BitPipe Terminal</h1>
        </header>

        <main id="terminal" class="flex-1 p-4 overflow-y-auto" onclick="document.getElementById('commandInput').focus()">
            <div id="output" class="whitespace-pre-wrap"></div>
            <div class="flex items-center">
                <span id="prompt" class="prompt-color"></span>
                <input type="text" id="commandInput" class="prompt-input pl-2" autofocus autocomplete="off" spellcheck="false"/>
            </div>
        </main>
    </div>

    <script>
        const terminal = document.getElementById('terminal');
        const output = document.getElementById('output');
        const commandInput = document.getElementById('commandInput');
        const promptElement = document.getElementById('prompt');
        
        const commandHistory = [];
        let historyIndex = -1;
        const API_URL = 'http://127.0.0.1:5000/execute';
        const AUTOCOMPLETE_URL = 'http://127.0.0.1:5000/autocomplete';

        commandInput.addEventListener('keydown', handleKeyDown);

        async function handleKeyDown(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                const command = commandInput.value.trim();
                if (command) {
                    if (commandHistory.length === 0 || commandHistory[commandHistory.length - 1] !== command) {
                       commandHistory.push(command);
                    }
                    historyIndex = commandHistory.length;
                    await processCommand(command);
                }
                commandInput.value = '';
            } else if (event.key === 'ArrowUp') {
                 event.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    commandInput.value = commandHistory[historyIndex];
                    commandInput.setSelectionRange(commandInput.value.length, commandInput.value.length);
                }
            } else if (event.key === 'ArrowDown') {
                event.preventDefault();
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    commandInput.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    commandInput.value = '';
                }
            } else if (event.key === 'l' && event.ctrlKey) {
                event.preventDefault();
                clearTerminal();
            } else if (event.key === 'Tab') {
                event.preventDefault();
                await handleAutocomplete();
            }
        }

        async function processCommand(command) {
            appendOutput(promptElement.textContent + ' ' + command);
            const [cmd, ...args] = command.toLowerCase().split(' ');

            if (cmd === 'clear') {
                clearTerminal();
                return;
            } else if (cmd === 'help') {
                const helpText = `
BitPipe Terminal - Custom Commands:
  ls           List directory contents
  cd [dir]     Change the current directory
  pwd          Print name of current/working directory
  mkdir [dir]  Make directories
  rm [file]    Remove files or empty directories (-r for recursive)
  status       Display system CPU, memory, and process info
  clear        Clear the terminal screen
  help         Show this help message
  theme        Change theme. Usage: theme [hacker|solarized|tokyo-night]

Other common shell commands like 'echo', 'cat', 'touch' are also supported.`;
                appendOutput(helpText.trim());
            } else if (cmd === 'theme') {
                const validThemes = ['tokyo-night', 'hacker', 'solarized'];
                if (args.length > 0 && validThemes.includes(args[0])) {
                    document.body.closest('.p-4').parentElement.dataset.theme = args[0];
                    appendOutput(`Theme changed to ${args[0]}`);
                } else {
                    appendOutput(`Usage: theme [tokyo-night|hacker|solarized]`);
                }
            } else {
                try {
                    const response = await fetch(API_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ command: command })
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const data = await response.json();
                    if(data.output) appendOutput(data.output);
                    updatePrompt(data.pwd);
                } catch (error) {
                    appendOutput(`Error: Could not connect to the backend. Is it running?`);
                    console.error("Fetch error:", error);
                }
            }
            scrollToBottom();
        }
        
        async function handleAutocomplete() {
            const text = commandInput.value;
            const parts = text.split(' ');
            const toComplete = parts[parts.length - 1];
            if (toComplete === '') return;

            try {
                const response = await fetch(AUTOCOMPLETE_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                const data = await response.json();
                const completions = data.completions;

                if (completions.length === 1) {
                    parts[parts.length - 1] = completions[0];
                    commandInput.value = parts.join(' ');
                } else if (completions.length > 1) {
                    appendOutput(promptElement.textContent + ' ' + text, false);
                    appendOutput(completions.join('   '), false);
                    scrollToBottom();
                }
            } catch (error) {
                console.error("Autocomplete error:", error);
            }
        }

        function appendOutput(message, withAnimation = true) {
            const line = document.createElement('div');
            line.textContent = message;
            if (withAnimation) {
                line.classList.add('fade-in');
            }
            output.appendChild(line);
        }

        function clearTerminal() {
             output.innerHTML = '';
             printWelcomeMessage();
        }

        function updatePrompt(pwd) {
            promptElement.textContent = `user@bitpipe:${pwd}$`;
        }
        
        function scrollToBottom() {
            terminal.scrollTop = terminal.scrollHeight;
        }

        function printWelcomeMessage() {
            const welcomeAscii = `
    ____  _ _   ____ ___ ___
    | __ )(_) |_|  _ \\_ _| _ \\
    |  _ \\| | __| |_) | ||  _/
    | |_) | | |_|  __/| || |
    |____/|_|\\__|_|  |___|_|
`;
            appendOutput(welcomeAscii, false);
            appendOutput('Welcome to BitPipe! Type "help" for a list of commands.', false);
            appendOutput('---------------------------------------------------------', false);
        }

        async function initializeTerminal() {
            clearTerminal();
            try {
                 const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command: "pwd" })
                });
                const data = await response.json();
                updatePrompt(data.pwd);
            } catch (error) {
                appendOutput('Could not connect to backend. Please start the Python server.', false);
            }
            scrollToBottom();
        }
        
        const mainContainer = document.querySelector('.w-full.max-w-4xl');
        if (mainContainer) {
            mainContainer.dataset.theme = 'tokyo-night';
            const originalProcessCommand = processCommand;
            processCommand = function(command) {
                const [cmd, ...args] = command.toLowerCase().split(' ');
                if (cmd === 'theme') {
                    const validThemes = ['tokyo-night', 'hacker', 'solarized'];
                    if (args.length > 0 && validThemes.includes(args[0])) {
                        mainContainer.dataset.theme = args[0];
                        appendOutput(`Theme changed to ${args[0]}`);
                        scrollToBottom();
                    } else {
                        appendOutput(`Usage: theme [tokyo-night|hacker|solarized]`);
                        scrollToBottom();
                    }
                } else {
                    originalProcessCommand(command);
                }
            }
        }

        initializeTerminal();
    </script>
</body>
</html>

